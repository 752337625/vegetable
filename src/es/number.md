---
prev: ./general
next: ./bigint
category:
  - ECMAScript
tag:
  - ECMAScript
---

# Number

JavaScript 对 15 位的十进制数都可以精确处理。大于 2 的 53 次方的数值，都无法保持精度。

大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 Infinity。

```js:no-line-numbers
Math.pow(2, 53)// 9007199254740992
// 多出的三个有效数字，将无法保存
9007199254740992111 // 9007199254740992000

// 超过 53 个二进制位的数值，无法保持精度
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true

// 超过 2 的 1024 次方的数值，无法表示
Math.pow(2, 1024) // Infinity
```

<!-- more -->

## 存储结构

JavaScript 中的数字类型只有 Number 一种，Number 类型采用 IEEE754 标准中的 “双精度浮点数” 来表示一个数字，不区分整数和浮点数 。

在 IEEE754 中，双精度浮点数采用 64 位存储，即 8 个字节表示一个浮点数 。其存储结构如下图所示：

![number](./img/number.png 'number')
![number](./img/number1.png 'number')

## 数值精度

精度最多只能到 53 个二进制位，这意味着，绝对值小于 2 的 53 次方的整数，即-2^53^ 到 2^53^，都可以精确表示。

```js:no-line:numbers
Math.pow(2, 53)
// 9007199254740992
Math.pow(2, 53) + 1
// 9007199254740992
Math.pow(2, 53) + 2
// 9007199254740994
Math.pow(2, 53) + 3
// 9007199254740996
Math.pow(2, 53) + 4
// 9007199254740996
```

上面代码中，大于 2 的 53 次方以后，整数运算的结果开始出现错误。所以，大于 2 的 53 次方的数值，都无法保持精度。由于 2 的 53 次方是一个 16 位的十进制数值，所以简单的法则就是，**JavaScript 对 15 位的十进制数都可以精确处理。**

## 数值范围

从存储结构中可以看出， 指数部分的长度是 11 个二进制(注意：11bit，不是 byte)，即指数部分能表示的最大值是 2047（2^11-1^），取中间值进行偏移，用来表示负指数，也就是说指数的范围是 [-1023,1024] 。因此，这种存储结构能够表示的数值范围为 2^1024^ 到 2^-1023^ ，超出这个范围的数无法表示 。2^1024^ 和 2^-1023^ 转换为科学计数法如下所示：

```js:no-line-numbers
1.7976931348623157e+308
5e-324
```

因此，JavaScript 中能表示的最大值是 1.7976931348623157 × 10^308^，最小值为 5 × 10^-324^。

```js:no-line-numbers
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324
```

如果数字超过最大值或最小值，JavaScript 将返回一个不正确的值，这称为 “正向溢出(overflow)” 或 “负向溢出(underflow)” 。

**如果一个数大于等于 2 的 1024 次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回 Infinity。**

**如果一个数小于等于 2 的-1075 次方（指数部分最小值-1023，再加上小数部分的 52 位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回 0。**

## 数值的表示法

JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如 35（十进制）和 0xFF（十六进制）,**数值也可以采用科学计数法表示**。

科学计数法允许字母 e 或 E 的后面，跟着一个整数，表示这个数值的指数部分。

以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。

- 小数点前的数字多于 21 位。(不要忘记 js 数值精度只有 15 位)

```js:no-line-numbers
1234567890123456789012
// 1.2345678901234568e+21

123456789012345678901
// 123456789012345680000
```

- 小数点后的零多于 5 个。

```js:no-line-numbers
// 小数点后紧跟 5 个以上的零，
// 就自动转为科学计数法
0.0000003 // 3e-7

// 否则，就保持原来的字面形式
0.000003 // 0.000003
```

## 数值的进制

- 十进制：没有前导 0 的数值。
- 八进制：有前缀 0o 或 0O 的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。
- 十六进制：有前缀 0x 或 0X 的数值。
- 二进制：有前缀 0b 或 0B 的数值。

## 与数值相关的全局方法

### parseInt()

- parseInt 方法用于将字符串转为整数。

  - 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。
  - 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回 NaN。
  - 如果字符串以 0x 或 0X 开头，parseInt 会将其按照十六进制数解析。
  - 如果字符串以 0 开头，将其按照 10 进制解析。
  - 对于那些会自动转为科学计数法的数字，parseInt 会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。(往往是错误的)

- parseInt 方法还可以接受第二个参数（2 到 36 之间），表示被解析的值的进制，返回该值对应的进制数。默认情况下，parseInt 的第二个参数为 10，即默认是十进制转十进制。
  - 第二个参数（2 到 36 之间）超出这个范围，则返回 NaN。
  - 如果第二个参数是 0、undefined 和 null，则直接忽略，采用默认情况 10，

### parseFloat()

parseFloat 方法用于将一个字符串转为浮点数。

### isNaN()

isNaN 方法可以用来判断一个值是否为 NaN。isNaN 只对数值有效，如果传入其他值，会被先转成数值。

**判断 NaN 更可靠的方法是，利用 NaN 为唯一不等于自身的值的这个特点，进行判断。**

```js:no-line-numbers
function myIsNaN(value) {
  return value !== value;
}
```

### isFinite()

isFinite 方法返回一个布尔值，表示某个值是否为正常的数值。

除了 Infinity、-Infinity、NaN 和 undefined 这几个值会返回 false，isFinite 对于其他的数值都会返回 true。

```js:no-line-numbers
isFinite(Infinity) // false
isFinite(-Infinity) // false
isFinite(NaN) // false
isFinite(undefined) // false
isFinite(null) // true
isFinite(-1) // true
isFinite('1') // true
isFinite('a') // true

```
