---
prev: false
next: false
category:
  - ThreeJS
tag:
  - ThreeJS
---

# 深入理解

<!-- more -->

## 样板

```
// 初始化场景
// 初始化摄像头，最后通过控件确定视图矩阵
  // 视图矩阵=包含：视点（camera.position）、上方向（camera.up）、观察目标（camera.lookAt）
  // 顶点坐标=透视投影矩阵（PerspectiveCamera） X 视图矩阵 X 模型矩阵（平移、缩放、旋转） X 原始顶点坐标（模型坐标）
  // 顶点坐标=正射投影矩阵（OrthographicCamera） X 视图矩阵 X 模型矩阵（平移、缩放、旋转） X 原始顶点坐标（模型坐标）
// 相机控件
// 帧动画

```

## 点线三角形立体 (BufferGeometry 的探讨)

==WeGGL 只提供了点、线、三角形开发技巧==

ThreeJS 的几何体都是通过 WebGL 点、线、三角形实现的

```js
const geometry = new THREE.BufferGeometry(); //
//类型化数组创建顶点数据
const vertices = new Float32Array([
  0,
  0,
  0, //顶点1坐标
  50,
  0,
  0, //顶点2坐标
  0,
  100,
  0, //顶点3坐标
  0,
  0,
  10, //顶点4坐标
  0,
  0,
  100, //顶点5坐标
  50,
  0,
  10, //顶点6坐标
]);
// 创建属性缓冲区对象
// 3个为一组，表示一个顶点的xyz坐标
const attribue = new THREE.BufferAttribute(vertices, 3);
// 设置几何体attributes属性的位置属性
geometry.attributes.position = attribue;
// 点渲染模式
const material = new THREE.PointsMaterial({
  color: 0xffff00,
  size: 10.0, //点对象像素尺寸
});
const points = new THREE.Points(geometry, material); //点模型对象
```

### 从 WeBGl 中分析缓存区的创建

==注意，数据：包含多个类型：点坐标、点大小、点颜色等==

- 创建缓存区
- 绑定缓存区到 webgl 内部目标（目标缓存区）
- 向目标缓存区写入数据
- 分配包含数据的目标缓存区指定变量（顶点着色器或片元着色器变量）

  ==注意：这里并不是把数交给变量，类似一个关联引用==

- 开启（我理解给变量赋值）

## 从 Three 中分析缓存区的创建

```js
const points = new THREE.Points(geometry, material); //点模型对象
```

我理解这一步才是缓存区创建的真正过程。

```js
const geometry = new THREE.BufferGeometry(); //
//类型化数组创建顶点数据
const vertices = new Float32Array([
  0,
  0,
  0, //顶点1坐标
  50,
  0,
  0, //顶点2坐标
  0,
  100,
  0, //顶点3坐标
  0,
  0,
  10, //顶点4坐标
  0,
  0,
  100, //顶点5坐标
  50,
  0,
  10, //顶点6坐标
]);
// 创建属性缓冲区对象
// 3个为一组，表示一个顶点的xyz坐标
const attribue = new THREE.BufferAttribute(vertices, 3);
// 设置几何体attributes属性的位置属性
geometry.attributes.position = attribue;
// 点渲染模式
const material = new THREE.PointsMaterial({
  color: 0xffff00,
  size: 10.0, //点对象像素尺寸
});
```

这几步只是对点坐标的融合

## 相机

### OrthographicCamera

```js
// 正投影相机
const width = window.innerWidth; //canvas 画布宽度
const height = window.innerHeight; //canvas 画布高度
const k = width / height; //canvas 画布宽高比
const s = 600; //控制 left, right, top, bottom 范围大小
const camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 8000);
```

```js
// Canvas画布跟随窗口变化
window.onresize = function () {
  const width = window.innerWidth; //canvas画布宽度
  const height = window.innerHeight; //canvas画布高度
  // 1. WebGL渲染器渲染的Cnavas画布尺寸更新
  renderer.setSize(width, height);
  // 2.1.更新相机参数
  const k = width / height; //canvas画布宽高比
  camera.left = -s * k;
  camera.right = s * k;
  // 2.2.相机的left, right, top, bottom属性变化了，通知threejs系统
  camera.updateProjectionMatrix();
};
```

### PerspectiveCamera

```js
const width = window.innerWidth; //canvas画布宽度
const height = window.innerHeight; //canvas画布高度F
new THREE.PerspectiveCamera(45, width / height, 1, 1000);
```

.aspect 属性受到 canvas 画布宽高度影响，当 canvas 画布尺寸发生变化的时候，需要更新透视投影相机 PerspectiveCamera 的.aspect 属性。

```js
window.onresize = function () {
  const width = window.innerWidth; //canvas画布宽度
  const height = window.innerHeight; //canvas画布高度F
  // width、height表示canvas画布宽高度
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
};
```
