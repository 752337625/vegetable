---
prev: false
next: false
category:
  - ThreeJS
tag:
  - ThreeJS
---

# 深入理解

<!-- more -->

## Three 内部顶点坐标转化

视图矩阵=包含：视点（camera.position）、上方向（camera.up）、观察目标（camera.lookAt）

顶点坐标=透视投影矩阵（PerspectiveCamera） X 视图矩阵 X 模型矩阵（平移、缩放、旋转） X 原始顶点坐标（模型坐标）

顶点坐标=正射投影矩阵（OrthographicCamera） X 视图矩阵 X 模型矩阵（平移、缩放、旋转） X 原始顶点坐标（模型坐标）

## 点线三角形立体 (BufferGeometry 的探讨)

==WeGGL 只提供了点、线、三角形开发技巧==

==当有索引顶点存在时，Three 更改的只有绘制函数 drawElement==

==Three 对多面体采用的是索引顶点绘制==

### 从 WeBGl 中分析缓存区的创建

==注意，数据：包含多个类型：点坐标、点大小、点颜色等==

- 创建缓存区
- 绑定缓存区到 webgl 内部目标（目标缓存区）
- 向目标缓存区写入数据
- 分配包含数据的目标缓存区指定变量（顶点着色器或片元着色器变量）

  ==注意：这里并不是把坐标交给变量，我理解类似一个关联引用==

- 开启（我理解给变量赋值）

### 从 Three 中分析缓存区的创建

```js
const points = new THREE.Points(geometry, material); //点模型对象
```

我理解这一步才是缓存区创建的真正过程，只是省略了。

```js
const geometry = new THREE.BufferGeometry(); //
const vertices = new Float32Array([
  0,
  0,
  0, //顶点1坐标
  50,
  0,
  0, //顶点2坐标
  0,
  100,
  0, //顶点3坐标
  0,
  0,
  10, //顶点4坐标
  0,
  0,
  100, //顶点5坐标
  50,
  0,
  10, //顶点6坐标
]);
// 3个为一组，表示一个顶点的xyz坐标
const attribue = new THREE.BufferAttribute(vertices, 3);
geometry.attributes.position = attribue;
const material = new THREE.PointsMaterial({
  color: 0xffff00,
  size: 10.0, //点对象像素尺寸
});
```

这几步只是对点坐标的融合

## BufferAttribute

```class
class  BufferAttribute{
  constructer(array : TypedArray, itemSize : Integer, normalized : Boolean){

  }
}
```

我理解：在 WebGL 中顶点坐标是复杂的：可能包含顶点、颜色和索引。所以在分配数据到目标缓存区，要指明 size、 stride 和 offset。

size=itemSize（分量个数）

stride=TypedArray.BYTES_PER_ELEMENT\*itemSize

offset:偏移

我理解：Three 的顶点坐标设计是分开的顶点、颜色和索引始终不会在一起。所以 size=itemSize（分量个数）、 stride=0、offset=0

综上：BufferAttribute 中的构造 itemSize 也就是分量个数

## 相机
